{"remainingRequest":"/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/babel-loader/lib/index.js!/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/src/components/BroadcastGraphics/SplitControl.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/src/components/BroadcastGraphics/SplitControl.vue","mtime":1568545481000},{"path":"/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/Users/sithum/Documents/GitHub/Oceania-Online-Results-Site-/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/es7.string.pad-start\";\nimport \"core-js/modules/es6.regexp.to-string\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport meosResultsApi from '@/meos-results-api';\nexport default {\n  data: function data() {\n    return {\n      now: new Date(),\n      competitorId: this.$route.params.competitorId,\n      radioId: this.$route.params.radioId,\n      resultsResponse: [],\n      resultsToDisplay: [],\n      // three element array\n      refreshTimer: '',\n      showSplits: false\n    };\n  },\n  created: function created() {\n    var _this = this;\n\n    // Refresh the results from the API\n    this.refreshResults(); // Update the now time every second\n\n    setInterval(function () {\n      return _this.now = new Date();\n    }, 1000); // Update the display\n\n    var updateLoop = function updateLoop() {\n      var nowMs = +new Date();\n      var updateIntervalMs = 1000;\n      var delay = Math.floor(nowMs / 1000) * 1000 - nowMs + updateIntervalMs;\n      setTimeout(function () {\n        _this.refreshResults();\n\n        updateLoop();\n      }, delay);\n    };\n\n    updateLoop();\n    setTimeout(function () {\n      _this.showSplits = true;\n    }, 1000);\n  },\n  filters: {\n    // Format the time for display\n    formatAbsoluteDiff: function formatAbsoluteDiff(t) {\n      if (t) {\n        // Convert into seconds\n        t = t / 10; // Format the time\n\n        var m, s;\n        m = Math.floor(Math.abs(t / 60)).toString();\n        s = Math.floor(Math.abs(t % 60)).toString().padStart(2, '0'); // If negative, they are faster\n\n        if (t < 0) {\n          return \"-\".concat(m, \":\").concat(s);\n        } // If positive, they are slower\n        else if (t > 0) {\n            return \"+\".concat(m, \":\").concat(s);\n          }\n      }\n\n      return null;\n    },\n    // Format the time for display\n    formatAbsoluteTime: function formatAbsoluteTime(t) {\n      if (t) {\n        // Convert into seconds\n        t = t / 10; // Format the time\n\n        var m, s;\n        m = Math.floor(Math.abs(t / 60)).toString();\n        s = Math.floor(Math.abs(t % 60)).toString().padStart(2, '0');\n        return \"\".concat(m, \":\").concat(s);\n      }\n\n      return null;\n    }\n  },\n  methods: {\n    refreshResults: function () {\n      var _refreshResults = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return meosResultsApi.getSplitResults(this.competitorId, this.radioId);\n\n              case 2:\n                this.resultsResponse = _context.sent;\n                _context.next = 5;\n                return this.determineDataToDisplay();\n\n              case 5:\n                this.resultsToDisplay = _context.sent;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function refreshResults() {\n        return _refreshResults.apply(this, arguments);\n      }\n\n      return refreshResults;\n    }(),\n    // Finds the two nearest times to the competitor\n    determineDataToDisplay: function determineDataToDisplay() {\n      // Create a variable to return\n      var resultsToReturn = [null, null, null]; // Store the array length\n\n      var radioResultsLength = this.resultsResponse.radioResults.length; // Set a variable to track whether the competitor has punched this radio\n\n      var competitorHasPunched = false; // Check whether the competitor has punched in the radioResults array\n\n      for (var i = 0; i < radioResultsLength; i++) {\n        if (this.resultsResponse.radioResults[i].competitorId == this.competitorId) {\n          competitorHasPunched = true;\n          break;\n        }\n      } // The competitor has punched the radio\n\n\n      if (competitorHasPunched) {\n        // Check if the competitor is FIRST\n        if (this.resultsResponse.radioResults[0].competitorId == this.competitorId) {\n          // Set the competitor to first place in resultsToReturn\n          resultsToReturn[0] = this.resultsResponse.radioResults[0]; // ...and set second and third places accordingly\n\n          if (radioResultsLength >= 2) resultsToReturn[1] = this.resultsResponse.radioResults[1];\n          if (radioResultsLength >= 3) resultsToReturn[2] = this.resultsResponse.radioResults[2];\n        } // Check if the competitor is LAST\n        else if (this.resultsResponse.radioResults[radioResultsLength - 1].competitorId == this.competitorId) {\n            // Check if we have two other competitors\n            if (radioResultsLength >= 3) {\n              // Set the competitor to last place in resultsToReturn\n              resultsToReturn[2] = this.resultsResponse.radioResults[radioResultsLength - 1]; // Set second last and third last places accordingly\n\n              resultsToReturn[1] = this.resultsResponse.radioResults[radioResultsLength - 2];\n              resultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 3];\n            } // Otherwise, we only have one other competitor (if the competitor was the only competitor they would be caught by the\n            // FIRST condition above)\n            else {\n                // Set the competitor to last place (i.e. second place) in resultsToReturn\n                resultsToReturn[1] = this.resultsResponse.radioResults[radioResultsLength - 1]; // Set second last place (i.e. first place, in this situation) accordingly\n\n                resultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 2]; // Leave index 2 empty, as there are only two competitors\n              }\n          } // Otherwise, the competitor is within the field somewhere\n          else {\n              // Locate the competitor in the radioResults array\n              var competitorIndex = -1;\n\n              for (var k = 0; k < radioResultsLength; k++) {\n                if (this.resultsResponse.radioResults[k].competitorId == this.competitorId) {\n                  competitorIndex = k;\n                  break;\n                }\n              } // Check we do inceed have the index\n\n\n              if (competitorIndex != -1) {\n                // Set the resultsToReturn array\n                // We're safe doing this, as the conditions above would capture if we risk going outside the bounds\n                // of the radioResults array\n                resultsToReturn[0] = this.resultsResponse.radioResults[competitorIndex - 1];\n                resultsToReturn[1] = this.resultsResponse.radioResults[competitorIndex];\n                resultsToReturn[2] = this.resultsResponse.radioResults[competitorIndex + 1];\n              }\n            }\n      } // The competitor has not punched the radio (they are still running towards that control)\n      else {\n          // Calculate their elapsed running time\n          var elapsedRunningTime = this.calculateElapsedTime(this.resultsResponse.competitor.startTime); // Check we have a time\n\n          if (elapsedRunningTime != null) {\n            // Create a dummy radioResults object for this competitor\n            var radioResultsObjForCompetitor = {\n              \"competitorId\": this.resultsResponse.competitor.competitorId,\n              \"name\": this.resultsResponse.competitor.name,\n              \"club\": this.resultsResponse.competitor.club,\n              \"radioTime\": null,\n              \"diff\": null,\n              \"rank\": null\n            }; // Is this the one and only competitor so far (i.e. no one else has gone through the radio yet)?\n\n            if (radioResultsLength == 0) {\n              // Set the competitor to first place in resultsToReturn\n              resultsToReturn[0] = radioResultsObjForCompetitor;\n            } // Otherwise, others have gone through the radio so we need to figure out where to put this competitor\n            else {\n                // Store the index of the immediate competitor we are beating\n                var beatingCompetitorAtIndex = -1; // Loop through all competitors who have punched the radio\n\n                for (var j = 0; j < radioResultsLength; j++) {\n                  if (elapsedRunningTime < this.resultsResponse.radioResults[j].radioTime) {\n                    beatingCompetitorAtIndex = j;\n                    break;\n                  }\n                } // Check if the competitor is FIRST\n\n\n                if (beatingCompetitorAtIndex == 0) {\n                  // Set the competitor to first place in resultsToReturn\n                  resultsToReturn[0] = radioResultsObjForCompetitor; // ...and set second and third places accordingly\n\n                  if (radioResultsLength >= 2) resultsToReturn[1] = this.resultsResponse.radioResults[0];\n                  if (radioResultsLength >= 3) resultsToReturn[2] = this.resultsResponse.radioResults[1];\n                } // Check if the competitor is LAST\n                else if (beatingCompetitorAtIndex == -1) {\n                    // Check if we have two other competitors\n                    if (radioResultsLength >= 2) {\n                      // Set the competitor to last place in resultsToReturn\n                      resultsToReturn[2] = radioResultsObjForCompetitor; // Set second last and third last places accordingly\n\n                      resultsToReturn[1] = this.resultsResponse.radioResults[radioResultsLength - 1];\n                      resultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 2];\n                    } // Otherwise, we only have one other competitor (if the competitor was the only competitor they would be caught by the\n                    // FIRST condition above)\n                    else {\n                        // Set the competitor to last place (i.e. second place) in resultsToReturn\n                        resultsToReturn[1] = radioResultsObjForCompetitor; // Set second last place (i.e. first place, in this situation) accordingly\n\n                        resultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 2]; // Leave index 2 empty, as there are only two competitors\n                      }\n                  } // Otherwise, the competitor is within the field somewhere\n                  else {\n                      // Set the resultsToReturn array\n                      // We're safe doing this, as the conditions above would capture if we risk going outside the bounds\n                      // of the radioResults array\n                      resultsToReturn[0] = this.resultsResponse.radioResults[beatingCompetitorAtIndex - 1];\n                      resultsToReturn[1] = radioResultsObjForCompetitor;\n                      resultsToReturn[2] = this.resultsResponse.radioResults[beatingCompetitorAtIndex];\n                    }\n              }\n          }\n        } // Return\n\n\n      return resultsToReturn;\n    },\n    // Calculates the competitors elapsed time\n    calculateElapsedTime: function calculateElapsedTime(competitorStartTime) {\n      // Check that we have a time\n      if (competitorStartTime) {\n        // Time of day in 10ths of seconds\n        var now = this.now;\n        var currentTimeSecs = (now.getSeconds() + 60 * now.getMinutes() + 60 * 60 * now.getHours()) * 10; // Calculate elapsed running time, we need to do this as all the radio times are relative to that competitor's running time,\n        // not absolute time\n\n        var elapsedRunningTime = currentTimeSecs - competitorStartTime; // console.log(elapsedRunningTime);\n        // Return the time\n\n        return elapsedRunningTime;\n      }\n\n      return null;\n    },\n    // Calculates the difference between two times\n    calculateDiffToLeader: function calculateDiffToLeader(secs) {\n      // Determine the difference - all times are in seconds (not 10ths of seconds)\n      var diff = secs - this.resultsResponse.radioResults[0].radioTime; // Return the diff\n\n      return diff;\n    },\n    // Displays the distance info (if available) for a particular radio\n    formatDistance: function formatDistance(d) {\n      // Convert the distance in meters into km for display, rounded to 1dp\n      var distanceInKm = parseFloat(d / 1000).toFixed(1); // Return the distance\n\n      return distanceInKm;\n    }\n  }\n};",{"version":3,"sources":["SplitControl.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n\n\t<div id=\"greenScreen\">\n\n\t\t<div id=\"graphicsContainer\">\n\n\t\t\t<table id=\"splitResults\" v-bind:class=\"{ show : showSplits }\">\n\n\t\t\t\t<tr v-for=\"result in resultsToDisplay\" v-if=\"result != null\" v-bind:key=\"result.competitorId\" v-bind:class=\"{'highlightCompetitor' : result.competitorId == competitorId}\">\n\t\t\t\t\t<td class=\"rank\">{{ result.rank }} </td>\n\t\t\t\t\t<td class=\"name\">{{ result.name }}</td>\n\t\t\t\t\t<td class=\"club\">{{ result.club }}</td>\n\t\t\t\t\t<td class=\"time\" v-if=\"result.diff != null && result.diff != 0\">{{ result.diff | formatAbsoluteDiff }}</td> <!-- punched, not the leader -->\n\t\t\t\t\t<td class=\"time\" v-else-if=\"result.diff == 0\">{{ result.radioTime | formatAbsoluteTime }}</td> <!-- punched, the leader -->\n\t\t\t\t\t<td class=\"time\" v-else-if=\"calculateDiffToLeader(calculateElapsedTime(resultsResponse.competitor.startTime)) == 0\">0:00</td> <!-- not punched, still going. this gets around the filter not correctly printing 0:00 -->\n\t\t\t\t\t<td class=\"time\" v-else>{{ calculateDiffToLeader(calculateElapsedTime(resultsResponse.competitor.startTime)) | formatAbsoluteDiff }}</td> <!-- not punched, still going -->\n\t\t\t\t</tr>\n\n\t\t\t\t<tr v-else>\n\t\t\t\t\t<td class=\"rank\"></td>\n\t\t\t\t\t<td class=\"name\"></td>\n\t\t\t\t\t<td class=\"club\"></td>\n\t\t\t\t\t<td class=\"time\"></td>\n\t\t\t\t</tr>\n\n\t\t\t</table>\n\n\t\t\t<table id=\"radioInfo\" v-bind:class=\"{ show : showSplits }\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<span class=\"className\">{{ resultsResponse.competitor.clsName }}</span>\n\t\t\t\t\t\t<span class=\"radioDetails\">{{ resultsResponse.radioInfo.radioName }} &mdash; {{ formatDistance(resultsResponse.radioInfo.distance) }} km {{ (resultsResponse.radioInfo.radioName == \"Finish\" ? '' : '(' + resultsResponse.radioInfo.percentage + '%)') }}</span>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\n\t\t\t<table id=\"runnerInfo\" v-bind:class=\"{ show : showSplits == false }\">\t\t\t\t\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"name\">{{ resultsResponse.competitor.name }}</td>\n\t\t\t\t\t<td class=\"class\">{{ resultsResponse.competitor.clsName }}</td>\n\t\t\t\t\t<td class=\"time\">{{ calculateElapsedTime(resultsResponse.competitor.startTime) | formatAbsoluteTime }}</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\n\t\t</div>\n\n\t</div>\n\n</template>\n\n<style scoped>\n\n\t#greenScreen {\n\t\twidth: 1920px;\n\t\theight: 1080px;\n\t\tbackground-color: green;\n\t\tposition: relative;\n\t}\n\n\n\n\t#graphicsContainer {\n\t\t/*background-color: red;*/\n\t\tposition: absolute;\n\t\tbottom: 100px;\n\t\tleft: 100px;\n\t\twidth: 640px;\n\t\theight: 198px;\n\t\toverflow: hidden;\n\t}\n\n\n\n\t#splitResults, #radioInfo, #runnerInfo {\n\t\tfont-family: Roboto;\n\t\tfont-size: 26px;\t\t\n\t\tborder-collapse: separate;\n\t\tborder-spacing: 0 4px;\n\t}\n\n\n\n\t#splitResults {\n\t\tposition: absolute;\n\t\ttop: 198px;\n\t\ttransition: top 1.0s ease-in-out;\n\t}\n\n\t#splitResults.show {\n\t\ttop: 0px;\n\t}\n\n\t#splitResults tr {\n\t\theight: 45px;\n\t\tbackground-color: white;\n\t}\n\n\t#splitResults tr td.rank {\n\t\twidth: 60px;\n\t\tpadding-right: 3px;\n\t\ttext-align: center;\n\t\tbackground-color: #e65c00;\n\t\tcolor: white;\n\t\tfont-weight: 500;\n\t\tborder-left: 3px solid #e65c00;\n\t}\n\n\t#splitResults tr td.name {\n\t\twidth: 360px;\n\t\ttext-transform: uppercase;\n\t\tfont-weight: 600;\n\t\tpadding: 0 10px;\n\t}\n\n\t#splitResults tr td.club {\n\t\twidth: 100px;\n\t\ttext-align: center;\n\t\t/*background-color: red;*/\n\t\tfont-weight: 300;\n\t}\n\n\t#splitResults tr td.time {\n\t\twidth: 110px;\n\t\ttext-align: right;\n\t\tpadding-right: 7px;\n\t\tfont-weight: 500;\n\t\tbackground-color: #e65c00;\n\t\tcolor: white;\n\t\tborder-right: 3px solid #e65c00;\n\t}\n\n\n\n\t#radioInfo {\n\t\twidth: 640px;\n\t\tposition: absolute;\n\t\tbottom: -5px;\n\t\topacity: 0;\n\t\ttransition: opacity 1.0s linear;\n\t}\n\n\t#radioInfo.show {\n\t\topacity: 1;\n\t}\n\n\t#radioInfo tr {\n\t\theight: 45px;\n\t}\n\n\t#radioInfo tr td {\n\t\theight: 45px;\n\t\ttext-transform: uppercase;\n\t\tpadding: 0 10px;\n\t\tpadding-top: 2px;\n\t\tbackground-color: #578a84;\n\t\tcolor: white;\n\t\tborder-right: 3px solid #578a84;\n\t\tborder-left: 3px solid #578a84;\n\t\tbackground-image: url('/images/orienteering-australia.png');\n\t\tbackground-size: 175px auto;\n\t\tbackground-position: center right;\n\t\tbackground-repeat: no-repeat;\n\t}\n\n\t#radioInfo tr td .className {\n\t\tfont-weight: 600;\n\t}\n\n\t#radioInfo tr td .radioDetails {\n\t\tpadding-left: 15px;\n\t\tfont-weight: 400;\n\t}\n\n\n\n\t#runnerInfo {\n\t\twidth: 640px;\n\t\tposition: absolute;\n\t\tbottom: -5px;\n\t\topacity: 0;\n\t\ttransition: opacity 1.0s linear;\n\t}\n\n\t#runnerInfo.show {\n\t\topacity: 1;\n\t}\n\n\t#runnerInfo tr {\n\t\theight: 45px;\n\t}\n\n\t#runnerInfo tr td.name {\n\t\twidth: 300px;\n\t\ttext-transform: uppercase;\n\t\tfont-weight: 600;\n\t\tpadding: 0 10px;\n\t\tbackground-color: white;\n\t}\n\n\t#runnerInfo tr td.class {\n\t\twidth: 100px;\n\t\ttext-align: right;\n\t\tpadding-right: 20px;\n\t\tbackground-color: white;\n\t}\n\n\t#runnerInfo tr td.time {\n\t\twidth: 100px;\n\t\ttext-align: right;\n\t\tpadding-right: 7px;\n\t\tfont-weight: 500;\n\t\tbackground-color: #e65c00;\n\t\tcolor: white;\n\t\tborder-right: 3px solid #e65c00;\n\t}\n\n</style>\n\n<script>\n\n\timport meosResultsApi from '@/meos-results-api'\n\n\texport default {\n\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tnow: new Date(),\n\t\t\t\tcompetitorId: this.$route.params.competitorId,\n\t\t\t\tradioId: this.$route.params.radioId,\n\t\t\t\tresultsResponse: [],\n\t\t\t\tresultsToDisplay: [], // three element array\n\t\t\t\trefreshTimer: '',\n\t\t\t\tshowSplits: false\n\t\t\t}\n\t\t},\n\n\t\tcreated () {\n\n\t\t\t// Refresh the results from the API\n\t\t\tthis.refreshResults()\n\n\t\t\t// Update the now time every second\n\t\t\tsetInterval(() => this.now = new Date(), 1000)\n\n\t\t\t// Update the display\n\t\t\tconst updateLoop = () => {\n\t\t\t\tconst nowMs = +new Date()\n\t\t\t\tconst updateIntervalMs = 1000;\n\t\t\t\tconst delay = Math.floor(nowMs / 1000) * 1000 - nowMs + updateIntervalMs\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.refreshResults()\n\t\t\t\t\tupdateLoop()\n\n\t\t\t\t}, delay)\n\t\t\t}\n\n\t\t\tupdateLoop()\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.showSplits = true;\n\t\t\t}, 1000)\n\n\t\t},\n\n\t\tfilters: {\n\n\t\t\t// Format the time for display\n\t\t\tformatAbsoluteDiff: function(t) {\n\t\t\t\t\n\t\t\t\tif (t) {\n\n\t\t\t\t\t// Convert into seconds\n\t\t\t\t\tt = t / 10;\n\n\t\t\t\t\t// Format the time\n\t\t\t\t\tvar m, s;\n\t\t\t\t\tm = (Math.floor(Math.abs(t/60)).toString());\n\t\t\t\t\ts = (Math.floor(Math.abs(t%60)).toString().padStart(2, '0'));\n\n\t\t\t\t\t// If negative, they are faster\n\t\t\t\t\tif (t < 0) {\n\t\t\t\t\t\treturn `-${m}:${s}`;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If positive, they are slower\n\t\t\t\t\telse if (t > 0) {\n\t\t\t\t\t\treturn `+${m}:${s}`;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t},\n\n\t\t\t// Format the time for display\n\t\t\tformatAbsoluteTime: function(t) {\n\t\t\t\t\n\t\t\t\tif (t) {\n\n\t\t\t\t\t// Convert into seconds\n\t\t\t\t\tt = t / 10;\n\n\t\t\t\t\t// Format the time\n\t\t\t\t\tvar m, s;\n\t\t\t\t\tm = (Math.floor(Math.abs(t/60)).toString());\n\t\t\t\t\ts = (Math.floor(Math.abs(t%60)).toString().padStart(2, '0'));\n\n\t\t\t\t\treturn `${m}:${s}`;\t\t\t\t\t\t\t\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t},\n\n\t\t},\n\n\t\tmethods: {\n\n\t\t\tasync refreshResults () {\n\n\t\t\t\t// Get the new results\n\t\t\t\tthis.resultsResponse = await meosResultsApi.getSplitResults(this.competitorId, this.radioId);\n\n\t\t\t\t// Refresh the data to display\n\t\t\t\tthis.resultsToDisplay = await this.determineDataToDisplay();\n\n\t\t\t},\n\n\t\t\t// Finds the two nearest times to the competitor\n\t\t\tdetermineDataToDisplay() {\n\n\t\t\t\t// Create a variable to return\n\t\t\t\tvar resultsToReturn = [null,null,null];\n\n\t\t\t\t// Store the array length\n\t\t\t\tconst radioResultsLength = this.resultsResponse.radioResults.length;\n\n\t\t\t\t// Set a variable to track whether the competitor has punched this radio\n\t\t\t\tvar competitorHasPunched = false;\n\n\t\t\t\t// Check whether the competitor has punched in the radioResults array\n\t\t\t\tfor (var i = 0; i < radioResultsLength; i++) {\n\t\t\t\t\tif (this.resultsResponse.radioResults[i].competitorId == this.competitorId) {\n\t\t\t\t\t\tcompetitorHasPunched = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// The competitor has punched the radio\n\t\t\t\tif (competitorHasPunched) {\n\n\t\t\t\t\t// Check if the competitor is FIRST\n\t\t\t\t\tif (this.resultsResponse.radioResults[0].competitorId == this.competitorId) {\n\n\t\t\t\t\t\t// Set the competitor to first place in resultsToReturn\n\t\t\t\t\t\tresultsToReturn[0] = this.resultsResponse.radioResults[0];\n\n\t\t\t\t\t\t// ...and set second and third places accordingly\n\t\t\t\t\t\tif (radioResultsLength >= 2)\n\t\t\t\t\t\t\tresultsToReturn[1] = this.resultsResponse.radioResults[1];\n\n\t\t\t\t\t\tif (radioResultsLength >= 3)\n\t\t\t\t\t\t\tresultsToReturn[2] = this.resultsResponse.radioResults[2];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if the competitor is LAST\n\t\t\t\t\telse if (this.resultsResponse.radioResults[radioResultsLength - 1].competitorId == this.competitorId) {\n\n\t\t\t\t\t\t// Check if we have two other competitors\n\t\t\t\t\t\tif (radioResultsLength >= 3) {\n\n\t\t\t\t\t\t\t// Set the competitor to last place in resultsToReturn\n\t\t\t\t\t\t\tresultsToReturn[2] = this.resultsResponse.radioResults[radioResultsLength - 1];\n\n\t\t\t\t\t\t\t// Set second last and third last places accordingly\n\t\t\t\t\t\t\tresultsToReturn[1] = this.resultsResponse.radioResults[radioResultsLength - 2];\n\t\t\t\t\t\t\tresultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 3];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we only have one other competitor (if the competitor was the only competitor they would be caught by the\n\t\t\t\t\t\t// FIRST condition above)\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t// Set the competitor to last place (i.e. second place) in resultsToReturn\n\t\t\t\t\t\t\tresultsToReturn[1] = this.resultsResponse.radioResults[radioResultsLength - 1];\n\n\t\t\t\t\t\t\t// Set second last place (i.e. first place, in this situation) accordingly\n\t\t\t\t\t\t\tresultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 2];\n\n\t\t\t\t\t\t\t// Leave index 2 empty, as there are only two competitors\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, the competitor is within the field somewhere\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Locate the competitor in the radioResults array\n\t\t\t\t\t\tvar competitorIndex = -1;\n\n\t\t\t\t\t\tfor (var k = 0; k < radioResultsLength; k++) {\n\t\t\t\t\t\t\tif (this.resultsResponse.radioResults[k].competitorId == this.competitorId) {\n\t\t\t\t\t\t\t\tcompetitorIndex = k;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check we do inceed have the index\n\t\t\t\t\t\tif (competitorIndex != -1) {\n\n\t\t\t\t\t\t\t// Set the resultsToReturn array\n\t\t\t\t\t\t\t// We're safe doing this, as the conditions above would capture if we risk going outside the bounds\n\t\t\t\t\t\t\t// of the radioResults array\n\t\t\t\t\t\t\tresultsToReturn[0] = this.resultsResponse.radioResults[competitorIndex - 1];\n\t\t\t\t\t\t\tresultsToReturn[1] = this.resultsResponse.radioResults[competitorIndex];\n\t\t\t\t\t\t\tresultsToReturn[2] = this.resultsResponse.radioResults[competitorIndex + 1];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// The competitor has not punched the radio (they are still running towards that control)\n\t\t\t\telse {\n\n\t\t\t\t\t// Calculate their elapsed running time\n\t\t\t\t\tconst elapsedRunningTime = this.calculateElapsedTime(this.resultsResponse.competitor.startTime);\n\n\t\t\t\t\t// Check we have a time\n\t\t\t\t\tif (elapsedRunningTime != null) {\n\n\t\t\t\t\t\t// Create a dummy radioResults object for this competitor\n\t\t\t\t\t\tconst radioResultsObjForCompetitor = {\n\t\t\t\t\t\t\t\"competitorId\": this.resultsResponse.competitor.competitorId,\n\t\t\t\t\t\t\t\"name\": this.resultsResponse.competitor.name,\n\t\t\t\t\t\t\t\"club\": this.resultsResponse.competitor.club,\n\t\t\t\t\t\t\t\"radioTime\": null,\n\t\t\t\t\t\t\t\"diff\": null,\n\t\t\t\t\t\t\t\"rank\": null\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Is this the one and only competitor so far (i.e. no one else has gone through the radio yet)?\n\t\t\t\t\t\tif (radioResultsLength == 0) {\n\n\t\t\t\t\t\t\t// Set the competitor to first place in resultsToReturn\n\t\t\t\t\t\t\tresultsToReturn[0] = radioResultsObjForCompetitor;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, others have gone through the radio so we need to figure out where to put this competitor\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t// Store the index of the immediate competitor we are beating\n\t\t\t\t\t\t\tvar beatingCompetitorAtIndex = -1;\n\n\t\t\t\t\t\t\t// Loop through all competitors who have punched the radio\n\t\t\t\t\t\t\tfor (var j = 0; j < radioResultsLength; j++) {\n\t\t\t\t\t\t\t\tif (elapsedRunningTime < this.resultsResponse.radioResults[j].radioTime) {\n\t\t\t\t\t\t\t\t\tbeatingCompetitorAtIndex = j;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check if the competitor is FIRST\n\t\t\t\t\t\t\tif (beatingCompetitorAtIndex == 0) {\n\n\t\t\t\t\t\t\t\t// Set the competitor to first place in resultsToReturn\n\t\t\t\t\t\t\t\tresultsToReturn[0] = radioResultsObjForCompetitor;\n\n\t\t\t\t\t\t\t\t// ...and set second and third places accordingly\n\t\t\t\t\t\t\t\tif (radioResultsLength >= 2)\n\t\t\t\t\t\t\t\t\tresultsToReturn[1] = this.resultsResponse.radioResults[0];\n\n\t\t\t\t\t\t\t\tif (radioResultsLength >= 3)\n\t\t\t\t\t\t\t\t\tresultsToReturn[2] = this.resultsResponse.radioResults[1];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check if the competitor is LAST\n\t\t\t\t\t\t\telse if (beatingCompetitorAtIndex == -1) {\n\n\t\t\t\t\t\t\t\t// Check if we have two other competitors\n\t\t\t\t\t\t\t\tif (radioResultsLength >= 2) {\n\n\t\t\t\t\t\t\t\t\t// Set the competitor to last place in resultsToReturn\n\t\t\t\t\t\t\t\t\tresultsToReturn[2] = radioResultsObjForCompetitor;\n\n\t\t\t\t\t\t\t\t\t// Set second last and third last places accordingly\n\t\t\t\t\t\t\t\t\tresultsToReturn[1] = this.resultsResponse.radioResults[radioResultsLength - 1];\n\t\t\t\t\t\t\t\t\tresultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 2];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Otherwise, we only have one other competitor (if the competitor was the only competitor they would be caught by the\n\t\t\t\t\t\t\t\t// FIRST condition above)\n\t\t\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t\t\t// Set the competitor to last place (i.e. second place) in resultsToReturn\n\t\t\t\t\t\t\t\t\tresultsToReturn[1] = radioResultsObjForCompetitor;\n\n\t\t\t\t\t\t\t\t\t// Set second last place (i.e. first place, in this situation) accordingly\n\t\t\t\t\t\t\t\t\tresultsToReturn[0] = this.resultsResponse.radioResults[radioResultsLength - 2];\n\n\t\t\t\t\t\t\t\t\t// Leave index 2 empty, as there are only two competitors\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Otherwise, the competitor is within the field somewhere\n\t\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t\t// Set the resultsToReturn array\n\t\t\t\t\t\t\t\t// We're safe doing this, as the conditions above would capture if we risk going outside the bounds\n\t\t\t\t\t\t\t\t// of the radioResults array\n\t\t\t\t\t\t\t\tresultsToReturn[0] = this.resultsResponse.radioResults[beatingCompetitorAtIndex - 1];\n\t\t\t\t\t\t\t\tresultsToReturn[1] = radioResultsObjForCompetitor;\n\t\t\t\t\t\t\t\tresultsToReturn[2] = this.resultsResponse.radioResults[beatingCompetitorAtIndex];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Return\n\t\t\t\treturn resultsToReturn;\n\n\t\t\t},\n\n\t\t\t// Calculates the competitors elapsed time\n\t\t\tcalculateElapsedTime(competitorStartTime) {\n\n\t\t\t\t// Check that we have a time\n\t\t\t\tif (competitorStartTime) {\n\n\t\t\t\t\t// Time of day in 10ths of seconds\n\t\t\t\t\tconst { now } = this;\n\t\t\t\t\tconst currentTimeSecs = (now.getSeconds() + (60 * now.getMinutes()) + (60 * 60 * now.getHours())) * 10;\n\n\t\t\t\t\t// Calculate elapsed running time, we need to do this as all the radio times are relative to that competitor's running time,\n\t\t\t\t\t// not absolute time\n\t\t\t\t\tconst elapsedRunningTime = currentTimeSecs - competitorStartTime;\n\n\t\t\t\t\t// console.log(elapsedRunningTime);\n\n\t\t\t\t\t// Return the time\n\t\t\t\t\treturn elapsedRunningTime;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t},\n\n\t\t\t// Calculates the difference between two times\n\t\t\tcalculateDiffToLeader(secs) {\n\n\t\t\t\t// Determine the difference - all times are in seconds (not 10ths of seconds)\n\t\t\t\tconst diff = (secs - this.resultsResponse.radioResults[0].radioTime);\n\n\t\t\t\t// Return the diff\n\t\t\t\treturn diff;\n\n\t\t\t},\n\n\t\t\t// Displays the distance info (if available) for a particular radio\n\t\t\tformatDistance(d) {\n\n\t\t\t\t// Convert the distance in meters into km for display, rounded to 1dp\n\t\t\t\tvar distanceInKm = parseFloat(d / 1000).toFixed(1);\n\n\t\t\t\t// Return the distance\n\t\t\t\treturn distanceInKm;\n\n\t\t\t},\n\n\t\t}\n\n\t}\n\n</script>"],"sourceRoot":"src/components/BroadcastGraphics"}]}